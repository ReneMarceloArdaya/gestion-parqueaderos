'use client'

import { useCallback, useEffect, useRef, useState } from 'react'
import { useParams } from 'next/navigation'
import { Canvas, FabricImage, Polygon, Point } from 'fabric'
import { Button } from '@/components/ui/button'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { createClient } from '@/lib/Supabase/supabaseClient'

// Crear cliente sin tipado estricto
const supabase: any = createClient()

interface Plaza {
  id: number
  points: { x: number; y: number }[]
  tipo: number | string | null
  codigo?: string
  estado?: string
}

interface PlazaFormData {
  codigo: string
  tipo_vehiculo_id: string
  estado: "libre" | "ocupada" | "reservada" | "fuera_servicio"
}

interface HoveredPlazaInfo {
  id: number
  codigo: string
  tipo: string
  estado: string
  x: number
  y: number
}

export default function DrawPlazasPage() {
  const { levelId } = useParams<{ levelId: string }>()
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [planoUrl, setPlanoUrl] = useState<string | null>(null)
  const [points, setPoints] = useState<{ x: number; y: number }[]>([])
  const [plazas, setPlazas] = useState<Plaza[]>([])
  const [vehicleType, setVehicleType] = useState('1')
  const [canvasInstance, setCanvasInstance] = useState<Canvas | null>(null)
  const [isDrawing, setIsDrawing] = useState(false)
  
  // Estados para el modal
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [isEditMode, setIsEditMode] = useState(false)
  const [editingPlazaId, setEditingPlazaId] = useState<number | null>(null)
  const [formData, setFormData] = useState<PlazaFormData>({
    codigo: '',
    tipo_vehiculo_id: '1',
    estado: 'libre'
  })
  
  // Estado para mostrar información al hacer hover
  const [hoveredPlaza, setHoveredPlaza] = useState<HoveredPlazaInfo | null>(null)
  const [currentPolygonPoints, setCurrentPolygonPoints] = useState<{ x: number; y: number }[]>([])

  // Mapeo de tipos de vehículo para mostrar
  const vehicleTypeNames: { [key: string]: string } = {
    '1': 'Auto',
    '2': 'Moto', 
    '3': 'Camión'
  }

  const reloadPlazas = useCallback(async () => {
    if (!levelId) return
    const { data, error } = await supabase
      .from('plazas')
      .select('id, coordenada, tipo_vehiculo_id, codigo, estado')
      .eq('nivel_id', parseInt(levelId, 10))

    if (error) {
      console.error('Error fetching plazas:', error)
      return
    }

    if (data) {
      const parsedPlazas = data.map((plaza: { 
        id: number; 
        coordenada: string; 
        tipo_vehiculo_id: number | null;
        codigo: string;
        estado: string;
      }) => {
        const coords = plaza.coordenada
          .replace('POLYGON((', '')
          .replace('))', '')
          .split(',')
          .map((p) => {
            const [x, y] = p.trim().split(' ').map(Number)
            return { x, y }
          })
        
        return {
          id: plaza.id,
          points: coords,
          tipo: plaza.tipo_vehiculo_id || null,
          codigo: plaza.codigo,
          estado: plaza.estado,
        }
      })
      setPlazas(parsedPlazas)
    }
  }, [levelId])

  // Cargar el plano
  useEffect(() => {
    const fetchPlano = async () => {
      if (!levelId) return
      
      const { data, error } = await supabase
        .from('planos')
        .select('url')
        .eq('nivel_id', parseInt(levelId, 10))
        .eq('principal', true)
        .single()

      if (error) {
        console.error('Error fetching plano:', error)
      } else if (data?.url) {
        console.log('Plano URL:', data.url)
        setPlanoUrl(data.url)
      }
    }

    fetchPlano()
    reloadPlazas()
  }, [levelId, reloadPlazas])

  // Inicializar canvas solo una vez
  useEffect(() => {
    if (!canvasRef.current) return

    const canvas = new Canvas(canvasRef.current, {
      width: 900,
      height: 600,
      backgroundColor: '#f0f0f0',
    })
    
    setCanvasInstance(canvas)

    // Zoom con rueda del mouse
    canvas.on('mouse:wheel', (opt) => {
      const delta = opt.e.deltaY
      let zoom = canvas.getZoom()
      zoom *= 0.999 ** delta
      
      if (zoom > 20) zoom = 20
      if (zoom < 0.01) zoom = 0.01
      
      canvas.zoomToPoint(new Point(opt.e.offsetX, opt.e.offsetY), zoom)
      opt.e.preventDefault()
      opt.e.stopPropagation()
    })

    return () => {
      canvas.dispose()
      setCanvasInstance(null)
    }
  }, []) // Solo se ejecuta una vez

  // Cargar imagen cuando planoUrl esté disponible
  useEffect(() => {
    if (!canvasInstance || !planoUrl) return

    FabricImage.fromURL(planoUrl, {
      crossOrigin: 'anonymous'
    }).then((fabricImg) => {
      const scaleX = 900 / fabricImg.width!
      const scaleY = 600 / fabricImg.height!
      const scale = Math.min(scaleX, scaleY)
      
      fabricImg.set({
        scaleX: scale,
        scaleY: scale,
        left: 0,
        top: 0,
        selectable: false,
        evented: false
      })
      
      canvasInstance.backgroundImage = fabricImg
      canvasInstance.renderAll()
      console.log('Imagen cargada correctamente')
    }).catch((error) => {
      console.error('Error cargando imagen:', error)
    })
  }, [canvasInstance, planoUrl])

  // Dibujar plazas existentes
  useEffect(() => {
    if (!canvasInstance || plazas.length === 0) return

    // Limpiar plazas anteriores (pero no la imagen de fondo ni polígonos temporales)
    const objectsToRemove = canvasInstance.getObjects().filter(obj => 
      !(obj as any).isTemp && obj.type === 'polygon' && !(obj as any).isDrawing
    )
    canvasInstance.remove(...objectsToRemove)

    // Agregar plazas con interactividad
    plazas.forEach((plaza) => {
      let fillColor = 'rgba(0, 100, 255, 0.3)' // libre (azul)
      let strokeColor = 'blue'
      
      if (plaza.estado === 'ocupada') {
        fillColor = 'rgba(255, 0, 0, 0.3)' // ocupada (rojo)
        strokeColor = 'red'
      } else if (plaza.estado === 'reservada') {
        fillColor = 'rgba(255, 165, 0, 0.3)' // reservada (naranja)
        strokeColor = 'orange'
      } else if (plaza.estado === 'fuera_servicio') {
        fillColor = 'rgba(128, 128, 128, 0.3)' // fuera de servicio (gris)
        strokeColor = 'gray'
      }

      const polygon = new Polygon(plaza.points, {
        fill: fillColor,
        stroke: strokeColor,
        strokeWidth: 2,
        selectable: true,
        evented: true,
        hoverCursor: 'pointer',
        moveCursor: 'pointer'
      })

      // Agregar datos de la plaza al objeto
      ;(polygon as any).plazaId = plaza.id
      ;(polygon as any).plazaData = plaza

      // Eventos para mostrar información al hacer hover
      polygon.on('mouseover', (e) => {
        if (!isDrawing) {
          const pointer = canvasInstance.getPointer(e.e)
          setHoveredPlaza({
            id: plaza.id,
            codigo: plaza.codigo || `Plaza ${plaza.id}`,
            tipo: vehicleTypeNames[plaza.tipo?.toString() || '1'] || 'Auto',
            estado: plaza.estado || 'libre',
            x: pointer.x,
            y: pointer.y
          })
        }
      })

      polygon.on('mouseout', () => {
        if (!isDrawing) {
          setHoveredPlaza(null)
        }
      })

      // Evento para editar plaza
      polygon.on('mousedown', (e) => {
        if (!isDrawing && e.e.detail === 2) { // Double click
          handleEditPlaza(plaza)
        }
      })

      canvasInstance.add(polygon)
    })
    canvasInstance.renderAll()
  }, [canvasInstance, plazas, isDrawing])

  // Manejar eventos de dibujo
  useEffect(() => {
    if (!canvasInstance) return

    const handleMouseDown = (options: any) => {
      if (!isDrawing) return

      // Evitar dibujar sobre plazas existentes
      if (options.target && (options.target as any).plazaId) {
        return
      }
      
      const pointer = canvasInstance.getPointer(options.e)
      const newPoint = { x: Math.round(pointer.x), y: Math.round(pointer.y) }
      const newPoints = [...points, newPoint]
      setPoints(newPoints)

      console.log('Punto agregado:', newPoint) // Debug

      // Verificar si se debe cerrar el polígono
      if (newPoints.length >= 3) {
        const firstPoint = newPoints[0]
        const distance = Math.sqrt(
          Math.pow(newPoint.x - firstPoint.x, 2) + Math.pow(newPoint.y - firstPoint.y, 2)
        )
        
        if (distance < 15) { // Aumentar la distancia de cierre
          setCurrentPolygonPoints(newPoints)
          openPlazaModal(false) // Abrir modal para nueva plaza
          return
        }
      }

      drawTempPolygon(newPoints)
    }

    canvasInstance.on('mouse:down', handleMouseDown)

    return () => {
      canvasInstance.off('mouse:down', handleMouseDown)
    }
  }, [canvasInstance, isDrawing, points])

  const drawTempPolygon = (points: { x: number; y: number }[]) => {
    if (!canvasInstance) return

    // Remover polígonos temporales
    const objectsToRemove = canvasInstance.getObjects().filter(obj => (obj as any).isTemp === true)
    canvasInstance.remove(...objectsToRemove)
    
    if (points.length >= 2) {
      const polygon = new Polygon(points, {
        stroke: 'red',
        strokeWidth: 2,
        fill: 'rgba(255, 0, 0, 0.1)',
        selectable: false,
        evented: false
      })
      ;(polygon as any).isTemp = true
      ;(polygon as any).isDrawing = true
      canvasInstance.add(polygon)
    }
    canvasInstance.renderAll()
  }

  // Funciones para manejar el modal
  const openPlazaModal = (editMode: boolean, plaza?: Plaza) => {
    setIsEditMode(editMode)
    if (editMode && plaza) {
      setEditingPlazaId(plaza.id)
      setFormData({
        codigo: plaza.codigo || '',
        tipo_vehiculo_id: plaza.tipo?.toString() || '1',
        estado: (plaza.estado as "libre" | "ocupada" | "reservada" | "fuera_servicio") || 'libre'
      })
    } else {
      setEditingPlazaId(null)
      setFormData({
        codigo: `P-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
        tipo_vehiculo_id: vehicleType,
        estado: 'libre'
      })
    }
    setIsModalOpen(true)
  }

  const handleEditPlaza = (plaza: Plaza) => {
    openPlazaModal(true, plaza)
  }

  const handleCloseModal = () => {
    setIsModalOpen(false)
    setIsEditMode(false)
    setEditingPlazaId(null)
    if (!isEditMode) {
      // Si estábamos creando una plaza nueva, limpiar el polígono temporal
      if (canvasInstance) {
        const objectsToRemove = canvasInstance.getObjects().filter(obj => (obj as any).isTemp === true)
        canvasInstance.remove(...objectsToRemove)
        canvasInstance.renderAll()
      }
      setPoints([])
      setCurrentPolygonPoints([])
      setIsDrawing(false)
    }
  }

  const handleStartDrawing = () => {
    console.log('Comenzando a dibujar') // Debug
    setIsDrawing(true)
    setPoints([])
    setHoveredPlaza(null) // Ocultar tooltip al comenzar a dibujar
  }

  const handleUndo = () => {
    if (points.length > 0) {
      const newPoints = points.slice(0, -1)
      setPoints(newPoints)
      drawTempPolygon(newPoints)
    }
  }

  const handleFormChange = (field: keyof PlazaFormData, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }

  const handleSavePlaza = async () => {
    try {
      if (isEditMode && editingPlazaId) {
        // Actualizar plaza existente
        const { error }: any = await supabase
          .from('plazas')
          .update({
            codigo: formData.codigo,
            tipo_vehiculo_id: parseInt(formData.tipo_vehiculo_id, 10),
            estado: formData.estado,
          })
          .eq('id', editingPlazaId)

        if (error) {
          console.error(error)
          alert('Error actualizando plaza')
        } else {
          alert('Plaza actualizada 🚗')
          handleCloseModal()
          reloadPlazas()
        }
      } else {
        // Crear nueva plaza
        if (currentPolygonPoints.length < 3) {
          alert('Una plaza necesita al menos 3 puntos.')
          return
        }

        const coordsWKT = `POLYGON((${currentPolygonPoints
          .map(p => `${p.x} ${p.y}`)
          .join(', ')}, ${currentPolygonPoints[0].x} ${currentPolygonPoints[0].y}))`;

        const { error } = await supabase.from('plazas').insert({
          nivel_id: parseInt(levelId!, 10),
          codigo: formData.codigo,
          tipo_vehiculo_id: parseInt(formData.tipo_vehiculo_id, 10),
          coordenada: coordsWKT,
          estado: formData.estado,
        } as any);

        if (error) {
          console.error(error)
          alert('Error guardando plaza')
        } else {
          alert('Plaza guardada 🚗')
          handleCloseModal()
          reloadPlazas()
        }
      }
    } catch (error) {
      console.error('Error:', error)
      alert('Error procesando la plaza')
    }
  }

  return (
    <div className="p-6 space-y-4 relative">{/* Agregado relative para tooltip */}
      <h1 className="text-xl font-bold">Dibujar plazas en el nivel {levelId}</h1>

      <div className="flex items-center gap-4">
        <label className="text-sm font-medium">Tipo de vehículo:</label>
        <Select value={vehicleType} onValueChange={setVehicleType}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Seleccione tipo" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="1">Auto</SelectItem>
            <SelectItem value="2">Moto</SelectItem>
            <SelectItem value="3">Camión</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {planoUrl && (
        <div className="text-sm text-gray-600">
          Imagen cargada: {planoUrl}
        </div>
      )}

      <div className="border rounded-lg shadow overflow-hidden">
        <canvas ref={canvasRef} className="border" />
      </div>

      <div className="flex gap-3">
        <Button 
          variant={isDrawing ? "destructive" : "default"}
          onClick={handleStartDrawing}
        >
          {isDrawing ? 'Dibujando...' : 'Comenzar a dibujar'}
        </Button>
        <Button variant="outline" onClick={handleUndo} disabled={!isDrawing || points.length === 0}>
          Deshacer punto
        </Button>
        <Button 
          variant="secondary" 
          onClick={() => {
            if (points.length >= 3) {
              setCurrentPolygonPoints(points)
              openPlazaModal(false)
            }
          }}
          disabled={!isDrawing || points.length < 3}
        >
          Cerrar plaza
        </Button>
      </div>

      <div className="text-sm text-gray-600">
        {isDrawing && (
          <p>Haz clic en el canvas para agregar puntos. Clic cerca del primer punto para cerrar.</p>
        )}
        {points.length > 0 && (
          <p>Puntos: {points.length}</p>
        )}
        {!isDrawing && (
          <p>Haz doble clic en una plaza existente para editarla. Pasa el cursor sobre una plaza para ver su información.</p>
        )}
      </div>

      {/* Tooltip para plazas existentes */}
      {hoveredPlaza && (
        <div 
          className="absolute bg-black text-white p-2 rounded text-xs z-10 pointer-events-none"
          style={{
            left: hoveredPlaza.x + 10,
            top: hoveredPlaza.y - 10,
          }}
        >
          <p><strong>{hoveredPlaza.codigo}</strong></p>
          <p>Tipo: {hoveredPlaza.tipo}</p>
          <p>Estado: {hoveredPlaza.estado}</p>
        </div>
      )}

      {/* Modal para crear/editar plaza */}
      <Dialog open={isModalOpen} onOpenChange={handleCloseModal}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {isEditMode ? 'Editar Plaza' : 'Nueva Plaza'}
            </DialogTitle>
            <DialogDescription>
              {isEditMode 
                ? 'Modifica los datos de la plaza seleccionada.'
                : 'Complete los datos de la nueva plaza.'
              }
            </DialogDescription>
          </DialogHeader>
          
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="codigo">Código de la plaza</Label>
              <Input
                id="codigo"
                value={formData.codigo}
                onChange={(e) => handleFormChange('codigo', e.target.value)}
                placeholder="Ej: A-01"
              />
            </div>
            
            <div className="grid gap-2">
              <Label htmlFor="tipo">Tipo de vehículo</Label>
              <Select 
                value={formData.tipo_vehiculo_id} 
                onValueChange={(value) => handleFormChange('tipo_vehiculo_id', value)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Seleccione tipo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="1">Auto</SelectItem>
                  <SelectItem value="2">Moto</SelectItem>
                  <SelectItem value="3">Camión</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid gap-2">
              <Label htmlFor="estado">Estado</Label>
              <Select 
                value={formData.estado} 
                onValueChange={(value) => handleFormChange('estado', value)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Seleccione estado" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="libre">Libre</SelectItem>
                  <SelectItem value="ocupada">Ocupada</SelectItem>
                  <SelectItem value="reservada">Reservada</SelectItem>
                  <SelectItem value="fuera_servicio">Fuera de servicio</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={handleCloseModal}>
              Cancelar
            </Button>
            <Button onClick={handleSavePlaza}>
              {isEditMode ? 'Actualizar' : 'Guardar'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}